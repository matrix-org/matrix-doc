
# MSC3073: Role-based access control

This is an alternative to [MSC2812](https://github.com/matrix-org/matrix-doc/pull/2812). The main
differences from Travis Ralston's proposal are:

* Flag-style permissions are tri-state.
* Invite, kick, ban permissions are scoped, instead of being flags.
* Ban and unban are separate permissions.
* The top role is implicit and called `T`, which is commonly known as the top type in the type
theory.
* Bottom role `⊥` is introduced for muting users and similar use cases.
* Self-banning has been introduced as a way to implement room blocking.
* Role inheritance and ordering introduced.

## Proposal

In a future room version...

**Note**: All identifiers are to follow [MSC2758](https://github.com/matrix-org/matrix-doc/pull/2758)
in this proposal.

Roles are declared using `m.role` state events where the state keys are arbitrary identifiers used
to differentiate between roles. An example `m.role` event's `content` would be:

```json
{
  "m.name": {
    "en": "Administrator"
  },
  "m.permissions": {
    "m.ban": {"m.targets": ["*"]},
    "m.roles": {
      "m.change": ["org.example.sponsors"],
      "m.assign": ["*"],
      "m.revoke": []
    }
  },
  "m.flair": ["mxc://0000000000000000000000000000000"]
}
```

The content is highly extensible/namespaced to permit additional fields being added by implementations
which may be interested. Role names have translation support. Language codes are per [BCP47](https://tools.ietf.org/html/bcp47),
with `en` being representative of English. In case a translation is missing, the client should derive
a fallback role name in terms of "can do X, cannot do Y".

Role names are recommended to be descriptive, however they are optional. By default, a role has
no permissions associated with it. This can be used to simply categorize members of a role for
easy identification rather than granting them any specific power - such examples may be wanting
to identify supporters of a project within a room.

Permissions are identifiers with an associated object which varies depending on the permission itself.
Most permissions have simple tri-state flag structure:
* `true`: allowed
* `false`: denied
* `null` or absent: neutral

When using this roles system, `m.room.power_levels` serves zero meaning including for the purposes of
authorization rules. The changes to the authorization rules are defined later in this proposal.

Roles may have optional flairs, which shall be set as elements in the `m.flair` array of URI strings.
Only allowed schemes are MXC (which should point to a media repository item) and DATA (for inline data,
which is for content deemed unsafe for uploading into media repository). The allowed media types are
16-bit 44.1kHz PCM, 16-bit 44.1kHz FLAC for audio; W3C SVG with square rendering canvas, a Lottie image
with square rendering canvas for vector graphics; PNG, DIB BMP, TIFF, FLIF lossless BPG, lossless WebP
with `8:8:8:8` colour space and square canvas with a dimension of an integer power of two pixels for
raster image.

### Identifying members in a role

On the applicable user's `m.room.member` state event, a new field of `m.roles` is added to be an array
of role IDs (state keys for `m.role` state events). For example:

```json
{
  "type": "m.room.member",
  "sender": "@alice:example.org",
  "content": {
    "membership": "join",
    "displayname": "Alice",
    "m.roles": [
      "T",
      "org.example.supporter"
    ]
  },
  "state_key": "@alice:example.org",
  "origin_server_ts": 1579809459351,
  "event_id": "$tKStv-i0ympmbHEhnxZxwSkXJP5r-0Svf19HACNYKG4",
  "room_id": "!example:example.org"
}
```

Adding/removing (changing) roles associated with a user is protected by a permission - see the proposed
permissions later in this proposal for more information.

### Default permissions structure

An implicit top role `T` is assumed to exist with universal permissions. This role is automatically
assigned to the room creator when they join for the first time, and the authorization rules will be
modified to allow this. An implicit bottom role `⊥` is similar, except it has no permissions at all,
instead of having universal permissions. However, no one is granted bottom role by default.

Permissions are otherwise granted as per their defaults to all users without any roles defined on
their membership event. By default, members do not get any roles associated with them upon joining
the room (with the exception of the room creator, as outlined above).

It is ill-formed to directly combine top and bottom roles in the same user's role list in any order.
It is also ill-formed to declare either of top or bottom roles as a role's parent.

### Execution order

The roles of user is listed in an ordered manner, and the following truth tables are used to combine
the roles to calculate the effective power of the user, starting by combining the first two elements,
and then the result of that with the third element, and so on.

| First operand  | `true`  | `false`  | `null`  |
|:--------------:|:-------:|:--------:|:-------:|
| Second operand |         |          |         |
| `true`         | `true`  | `true`   | `true`  |
| `false`        | `null`  | `false ` | `false` |
| `null`         | `true ` | `false`  | `null`  |

List- or glob- scoped roles are calculated differently. If a rule only allows specifying whitelists,
those whitelists are additive. If a rule has both white- and black- lists, they are combined as such:

* Black- and whitelists are additive within themselves.
* If a selector is in the whitelist in one rule and in the blacklist in a later rule of the same kind,
then the entry is removed from the effective whitelist and added to the effective blacklist. 
* If a selector is in the blacklist in one rule and in the whitelist in a later rule of the same kind,
then the entry is removed from the effective blacklist and added to the effective whitelist.
* If a selector is overridden in a later rule of the same kind by a more generic selector that covers
a superset of the former, then the former entry can be removed from the further computation, however
that does not make such an override illegal. The burden of proof for such an optimisation produces
the same result as the unoptimised list is in the implementation. A client implementation may utilise
this rule to produce diagnostics against adding redundant rules and roles.

### Inheritance

Roles can list parent roles with `m.parent` attribute. This shall take an unordered list of role
identifiers. The permissions of the role in question and the recursive parents of role shall be
OR-ed to get the effective permission of that role. Inheritance cycles, if they arise, shall be
broken using the following algorithm:

* The role that is explicitly declared in the role listing is the bottom-most in a particular
inheritance tree.
* If multiple roles declared in the list participate in the cycle, then role that has created
after-most wrt state resolution amongst the role that participate in the cycle is the bottommost
in the inheritance tree.
* When a cycle is broken, all other parent relationships from the node that has its cycle broken
are also ignored.

Inheritance combines the glob- or list- scoped permissions using the algorithm mentioned in the
"execution order" subheading.

### Proposed initial permissions

The following permissions are proposed to be included in the spec. They are all direct correlations
to the existing `m.room.power_levels` fields.

#### Common permission format

For simple permissions, the key is the action and the value is the flag, like `"m.room.message": true`.
The default is neutral.

#### `m.invite`

Whether or not a user can be invited to the room by someone with the applicable role.

Permission body comprises of white and black- lists of acceptable invite targets in the glob format.
```json
{
  "m.targets": 
  {
   "allow": [
    "example.com"
  ],
  "deny": [
  "example.org"
  ]
  }
}
```
This is **disallowed** by default. The top role `T` has this all-allowed, i.e:
```json
{
  "m.targets": 
  {
   "allow": [
    "*"
  ],
  "deny": []
  }
}
```
The actual acceptable invite target set is calculated as follows:
* Deny those explicitly denied by `deny` in the `m.targets` or `deny` in the server ACL.
* Allow those explicitly alllowed both `allow` in the `m.targets`.
* Deny the rest.

#### `m.grant`

Whether or not a user can accept a knock by someone with the applicable role.

Permission body comprises of white and black- lists of acceptable knock sources
in the glob format.
```json
{
  "m.sources": 
  {
   "allow": [
    "example.com"
  ],
  "deny": [
  "example.org"
  ]
  }
}
```
This is **disallowed** by default. The top role `T` has this all-allowed, i.e:
```json
{
  "m.sources": 
  {
   "allow": [
    "*"
  ],
  "deny": []
  }
}
```
The actual acceptable knock source set is calculated as follows:
* Deny those explicitly denied by `deny` in the `m.sources` or `deny` in the server ACL.
* Allow those explicitly alllowed both `allow` in the `m.sources`.
* Deny the rest.

#### `m.ban`

Whether or not a user can be banned from the room by someone with the applicable role.

The permission attribute `m.targets` includes a list of globs of users and/or roles that can be targeted:
```json
{
  "m.targets": [
    "@*:example.org"
  ]
}
```
The top role `T` has the equivalent of:
```json
{
  "m.targets": [
    "*"
  ]
}
```
Users are allowed to ban themselves regardless of this permission. Such a ban where banning and banned user
are the same are called self-bans, and shall be irreversible.

#### `m.unban`

Whether or not a user can be unbanned from the room by someone with the applicable role. This role
uses the common permission format, and pre-ban powers of the banned user is ignored in the permission
computation. Self-bans cannot be reversed.

This is **disallowed** by default. Top role `T` has it allowed.

#### `m.kick`

Whether or not a user can be kicked from the room by someone with the applicable role.

The permission attribute `m.targets` includes a list of globs of users and/or roles that can be targeted:
```json
{
  "m.targets": [
    "@*:example.org"
  ]
}
```
The top role `T` has the equivalent of:
```json
{
  "m.targets": [
    "*"
  ]
}
```

#### `m.redact`

Which senders can have their events redacted by someone with the applicable role. Like `redact` in the
power level structure, this only affects other people than the sender - self-redaction is covered by
`m.redact.self`.

The permission body for this would be:

```json
{
  "m.senders": [
    "@*:example.org"
  ],
  "m.types": [
  "m.room.message"
  ]
}
```

The `m.senders` is an array of [globs under MSC2810](https://github.com/matrix-org/matrix-doc/pull/2810)
for which senders can have their events redacted by users with the applicable role. The `m.types` array
is an array of globs (again, under MSC2810) for the event types that this rule allows to be redacted. 

By default, both arrays will be empty to denote that users do not have permission to redact other people's
events of any type. Top role T has the equivalent of `["*"]` for both, meaning anyone may have their messages
redacted by users in the applicable role.

This rule can be defined multiple times in a role to allow redaction of different event types for
different event authors. For revision deletions of edited events, the user who sent the edited
revision counts, not the sender of the original revision.

#### `m.edit`

Which senders can have their events edited by someone with the applicable role. Like `redact` in the
power level structure, this only affects other people than the sender - self-edit is covered by
`m.redact.self`. This permission only applies to non-state events.

The permission body for this would be:

```json
{
  "m.senders": [
    "@*:example.org"
  ],
  "m.types": [
  "m.room.message"
  ]
}
```

The `m.senders` is an array of [globs under MSC2810](https://github.com/matrix-org/matrix-doc/pull/2810)
for which senders can have their events edited by users with the applicable role. The `m.types` array
is an array of globs (again, under MSC2810) for the event types that this rule allows to be edited.

By default, both arrays will be empty to denote that users do not have permission to edit other people's
events of any type. Top role T has the equivalent of `["*"]`, meaning anyone may have their messages
edited by users in the applicable role.

This rule can be defined multiple times in a role to allow redaction of different event types for
different event authors. For editing of previously edited events, the both the original sender and
the user who has sent the last revision that has since been not redacted count.

#### `m.events`

Which room events (state and otherwise) can be sent by users with the applicable role.

The permission body for this would be:

```json
{
  "m.state": {"*": true},
  "m.room": {
    "m.room.message": true,
    "*": false
  }
}
```

Room events are split into two kinds: `m.state` for state events, and `m.room` for all other room events.
Note that EDUs like presence and typing notifications are not (currently) handled by this proposal. Each
kind of event is an object of rules which are executed in order - the first rule that matches as allowed
will permit the user to send the applicable event.

Both are comprised mappings of glob-scoped permissions, where the mapping comprises of objects where
the key is a glob selector and the value is the permission value.

* `m.state` defaults to an implicit `"*": false` rule. When the mapping is explicitly
  empty, this deny rule persists.
* `m.room` defaults to an implicit `"*": true` rule. When the mapping is explicitly
  empty, an implicit deny rule of `"*": false` is present. This is to ensure that
  announcement-only rooms can be created by simply specifying `"m.room": {}`.

The top role `T` has the equivalent of the following:

```json
{
  "m.state": {"*": true},
  "m.room": {"*": true}
}
```

#### `m.redact.self`

Which room events (state and otherwise) can be edited or redacted. This permission only covers the events
sent by the same user.

The permission body for this would be:

```json
{
  "m.state": {"*": true},
  "m.room": {
    "m.room.message": true,
    "*": false
  }
}
```

This is **allowed** by default.

#### `m.notifications`

Which kinds of notifications users in the applicable role are able to trigger.

The permission body for this would be:

```json
{
  "m.room": true,
  "T": false,
  "org.example.user": true
}
```

The key of the object is the notification kind (with `m.room` being the `@room` permission level), and the
value is whether or not the role allows it to be triggered. By default, all notifications are disallowed.
If any of the rules explicitly match false for a given notification, the notification is disallowed. Else if
there is at least one rule explicitly match true for a given notification, the notification is allowed.

The top role `T` has it all-allowed.

#### `m.roles`

Whether or not users in the applicable role are able to add/change roles or add/remove them to users.

The permission body for this would be:

```json
{
  "m.change": [
    "org.example.*",
  ],
  "m.assign": [
    "T"
  ],
  "m.revoke": [
    "*"
  ]
}
```

All three properties are arrays of globs ([MSC2810](https://github.com/matrix-org/matrix-doc/pull/2810))
which are matched against role IDs (state keys of `m.role` events). All 3 arrays default to empty, implying
that all related actions are denied. Arrays are ordered and are matched as first-allowed wins.

`m.change` denotes which roles a user in the applicable role will be able to modify the properties of.
This can mean that the user might be able to modify a role they are currently assigned to.

`m.assign` denotes which roles a user in the applicable role will be able to assign (add) to users in
the room. This would be done through the `m.roles` property of the target user's membership event. The user
is able to target themselves.

`m.revoke` is the opposite of `m.assign`: it is which roles users in the applicable role will be able
to *remove* from a user's `m.roles` array on their membership event. Users are still able to target themselves
here.

The top role `T` has the equivalent of the following:
```json
{
  "m.change": ["*"],
  "m.assign": ["*"],
  "m.revoke": ["*"]
}
```

### Use-case adoption

Not all rooms will require the changes proposed here, and thus it may be important to support the existing
power levels structure in parallel. Some potential solutions for this include sending state events into
a room to indicate the switch of systems, however this could potentially cause problems with authorization
if a server were to miss an event. This proposal offers an awkward, but hopefully viable, solution that
may be extended to other similar features in the future.

Room versions reserved by the Matrix protocol ending with `.1` are indicative of the server supporting
the principles of that room version with the role system proposed here used in place of `m.room.power_levels`.
For the purposes of authorization rules, this proposal does not support room versions 1 through 5 as
currently reserved by the specification - the minimum viable set of authorization rules are a modified
v6 set as described later in this proposal.

The specification will remain responsible for defining what the `.1` version of a room version looks like,
when new versions are being introduced.

**Rationale**: The specification reserves room versions consisting of `[0-9.]` for use by the protocol,
but does not reserve anything using `[a-z\-]` as otherwise allowed by room versions. Ideally, the protocol
would have reserved a dash and some letters to assist with denoting various features that may be included
in a given room version, however `.1` works just as well.

For clarity: room version `6.1` would mean the room uses a role-based permission system while room version
`6` uses the existing power levels structure. When room version `7` is introduced through an MSC, it would
also define a `7.1` with any modifications required to continue supporting a role-based approach.

This proposal does not include a solution for custom room versions intentionally. Implementations using
custom room versions are welcome to invent their own scheme for identifying role-based approach usage.

### Expected server behaviour for profile/membership changes

***TODO - This needs defining***

### Precise changes to v6's authorization rules

Using room version 6 as a reference for authorization rules, the authorization rules for this MSC
would be as follows.

For determining whether a given user in a given room has a given permission:

* If the user's membership is not `join`, the user does not have any permissions.
* For each role ID defined by the `m.roles` array (default empty, ordered) on the user's membership event:
  * If there is no associated `m.role` state event in the room, skip.
  * Interpret the permission on the `m.role` state event to a single boolean flag to denote whether
    the user is allowed (true) or disallowed (false) to continue.
    * For unknown permission types (eg: custom namespaces), the default is to imply disallowed.
  * If the user is granted (allowed) the permission, return true to let the user continue the action.
  * If no roles have granted (allowed) the permission, return false to deny the user's action.

For authorizing events themselves:

***TODO - This needs defining***

## Potential issues

Roles are controversial as a power scheme and moderation structure - this is why the proposal actively
tries to keep the `m.room.power_levels` around. A roles approach is often better bridged to some
platforms (like Discord), whereas a power levels approach has a much stronger use case for others.
Similarly, it can be argued by several communities that roles are more natural feeling while other
communities will argue that power levels are more natural - it's largely a matter of preference and
community-specific interactions which define which is "better".

This roles approach is quite confusing as well and may lead to several implementation issues. This
MSC, and the relevant specification if this MSC makes it that far, should include examples ranging
from simple to complex for implementations to test against. As the ecosystem makes more general use
of a roles-based approach, those examples should be updated to better represent what is available
in the wild.

As already discussed, the room version identification approach is suboptimal but appears to be a
good enough compromise pending larger discussions with members of the ecosystem. Refer to that
section for more information.

How permissions are calculated in this scheme unfortunately means authorisation of users with
regards to various event types can no longer be efficiently precomputed. However, it is still
possible to cache the results of permission calculations.

## Alternatives

Roles are already an alternative to existing permissions model. By extension, there are several other
systems which may be valuable and have their own merits. The intention of this proposal is to
demonstrate an opt-in style permissions systems for the rooms/communities which have a requirement
to use such a system. It is not proposed that this system become the default under any circumstance
for all of Matrix.

## Security considerations

Changing the entire permissions system is dangerous and could lead to multiple security vulnerabilities.
Many have been already solved or considered by the existing power level system, and where possible
those semantics have been brought into this proposal.

## Frequently asked questions

1. Why allow self-banning?

  This is a way to implement room blocking without introducing any extra data structures?

2. Why is the top role implicit and named `T` without any namespace?

  The top role concept should be familiar to many administrators from other protocols, and `T` is the name
  for the top type.
  
3. Why allow restricting self-editing and self-retraction? Why separate unban permission?

  These may be useful for corporate, school and government (including military) use cases.
  
4. Why allow editing others' messages? 

  This may be useful to remove sensitive information and/or correct false statements.
  
## Unstable prefix

Implementations should use a room version of `org.matrix.msc3072` while this MSC is not in a published
version of the specification. Because all the events would be isolated to this highly customized
room version, there is no requirement to avoid the usage of the `m.*` namespace.
